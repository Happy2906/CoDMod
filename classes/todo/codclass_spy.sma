/* Plugin generated by AMXX-Studio */
#include <amxmodx>
#include <amxmisc>
#include <fun>
#include <fakemeta>
#include <engine>
#include <hamsandwich>
#include <codmod>
#define PLUGIN "Spy [TF2]"
#define VERSION "1.0"
#define AUTHOR "CheQ"
#define PASEK 5178
#define PASEK_LAD 4321
new bool:jest_niewidzialny[32];
new przez[32];
new czas[32]
new HUD;
new bool:is_spy[32];
new const nazwa[] = "Super Szpieg";
new const opis[] = "Ma p228,noz. wpisujac /pomoc dowiesz sie jak grac ";
new const bronie = 1<<CSW_P228 | 1<<CSW_KNIFE;
new const zdrowie = -5;
new const kondycja = 0;
new const inteligencja = 0;
new const wytrzymalosc = 0;
public plugin_init() {
register_plugin(PLUGIN, VERSION, AUTHOR)

cod_register_class(nazwa, opis, bronie, zdrowie, kondycja, inteligencja, wytrzymalosc);

RegisterHam(Ham_Spawn,"player","Spawn",1);
RegisterHam(Ham_TakeDamage, "player", "TakeDmg");
register_clcmd("say /pomoc","Pomoc")

register_forward(FM_PlayerPreThink, "PokazPasek");

HUD= CreateHudSyncObj()
}
public Pomoc(id)
{
if(is_spy[id])
{
client_print(id,print_chat,"Prawym klawiszem myszki wlaczasz niewidzialnosc")
client_print(id,print_chat,"Masz 10 sekund ale przy jakimkolwiek ataku jestes widzialny")
client_print(id,print_chat,"Masz 1/1 z noza gdy atakujesz z Tylu przeciwnika")
client_print(id,print_chat,"Klasa Wykonana przez CheQ'a.")
}
}
public cod_class_enabled(id)
{
is_spy[id] = true;
czas[id] = 10;
}
public cod_class_disabled(id)
{
is_spy[id] = false;
set_user_rendering(id, kRenderFxGlowShell, 0, 0, 0, kRenderTransColor, 255);
}
public Spawn(id)
{
if(is_spy[id])
{
przez[id]=255
remove_task(id + 9823)
remove_task(id + PASEK)
jest_niewidzialny[id]=false;
czas[id] = 10;
client_print(id,print_chat,"Nie wiesz jak grac Super Szpiegiem? Wpisz /pomoc")
}
}

public client_PreThink(id)
{
if(!is_user_alive(id) || !is_spy[id])
return PLUGIN_CONTINUE;

if((pev(id,pev_button) & IN_ATTACK2) && (pev(id,pev_oldbuttons) & IN_ATTACK2) && czas[id] && jest_niewidzialny[id])
{

remove_task(id + 9823)
remove_task(id+PASEK)
remove_task(id+PASEK_LAD)
set_user_rendering(id, kRenderFxGlowShell, 0, 0, 0, kRenderTransColor, 255);
przez[id] = 255;

if(czas[id]<10)
set_task(2.0,"LadowaniePaska",id+PASEK_LAD)
}
if((pev(id,pev_button) & IN_ATTACK2) && (pev(id,pev_oldbuttons) & IN_ATTACK2) && czas[id] && !jest_niewidzialny[id])
{
remove_task(id+PASEK_LAD)
remove_task(id+PASEK)
remove_task(id + 9823)
set_task(0.1,"niewidzialny",id + 9823)
}
if((pev(id,pev_button) & IN_ATTACK) && (jest_niewidzialny[id]))
{
if(task_exists(id + 9823))
remove_task(id + 9823)

remove_task(id+PASEK)
set_user_rendering(id, kRenderFxGlowShell, 0, 0, 0, kRenderTransColor, 255);
przez[id] = 255;
jest_niewidzialny[id]=false;
if(czas[id]<10)
set_task(1.0,"LadowaniePaska",id+PASEK_LAD)
}
return PLUGIN_CONTINUE;
}
public TakeDmg(this, idinflictor, idattacker, Float:damage, damagebits)
{
if(!is_user_alive(this) || !is_user_connected(this) || !is_user_connected(idattacker) || get_user_team(this) == get_user_team(idattacker))
return HAM_IGNORED;

if(!is_spy[idattacker])
return HAM_IGNORED;

new health = get_user_health(this);
new weapon = get_user_weapon(idattacker);

if(health < 2)
return HAM_IGNORED;


if(weapon == CSW_KNIFE && !UTIL_In_FOV(this, idattacker) && UTIL_In_FOV(idattacker, this))
damage=float(health);

SetHamParamFloat(4, damage);
return HAM_IGNORED;
}
public niewidzialny(id)
{
id-=9823;
if(przez[id]>0)
{
przez[id]-=15;
set_user_rendering(id, kRenderFxGlowShell, 0, 0, 0, kRenderTransColor, przez[id]);
set_task(0.1,"niewidzialny",id + 9823)
}
else
{
client_print(id,print_center,"Jestes niewidzialny")
remove_task(id + 9823)
jest_niewidzialny[id]=true;
set_task(1.0,"CzasFun",id+PASEK)
return PLUGIN_CONTINUE;
}
return PLUGIN_CONTINUE;
}
public CzasFun(id)
{
id-=PASEK;

if(czas[id]!=0)
{
czas[id]-=1;
set_task(1.0,"CzasFun",id+PASEK)
}
else
{
set_user_rendering(id, kRenderFxGlowShell, 0, 0, 0, kRenderTransColor, 255);
przez[id] = 255;
jest_niewidzialny[id]=false;
remove_task(id+PASEK)
set_task(2.0,"LadowaniePaska",id+PASEK_LAD)
}
}
public LadowaniePaska(id)
{
id-=PASEK_LAD;
jest_niewidzialny[id]=false;
if(czas[id]<10)
{
czas[id]++
set_task(1.0,"LadowaniePaska",id+PASEK_LAD)
}
else
remove_task(id+PASEK_LAD)
}
public PokazPasek(id)
{
if(!is_user_alive(id) || !is_spy[id])
return PLUGIN_CONTINUE;

if(czas[id]<4)
set_hudmessage(255, 0, 0, 0.03, 0.6, 0, 0.0, 0.3, 0.0, 0.0);
else
set_hudmessage(0, 255, 0, 0.03, 0.6, 0, 0.0, 0.3, 0.0, 0.0);


ShowSyncHudMsg(id, HUD,"Spy^n[------%d-----]",czas[id])
return PLUGIN_CONTINUE;
}
//Kod wziety CodMod.
stock bool:UTIL_In_FOV(id,target)
{
if (Find_Angle(id,target,9999.9) > 0.0)
return true;

return false;
}
stock Float:Find_Angle(Core,Target,Float:dist)
{
new Float:vec2LOS[2];
new Float:flDot;
new Float:CoreOrigin[3];
new Float:TargetOrigin[3];
new Float:CoreAngles[3];

pev(Core,pev_origin,CoreOrigin);
pev(Target,pev_origin,TargetOrigin);

if (get_distance_f(CoreOrigin,TargetOrigin) > dist)
return 0.0;

pev(Core,pev_angles, CoreAngles);

for ( new i = 0; i < 2; i++ )
vec2LOS[i] = TargetOrigin[i] - CoreOrigin[i];

new Float:veclength = Vec2DLength(vec2LOS);

//Normalize V2LOS
if (veclength <= 0.0)
{
vec2LOS[0] = 0.0;
vec2LOS[1] = 0.0;
}
else
{
new Float:flLen = 1.0 / veclength;
vec2LOS[0] = vec2LOS[0]*flLen;
vec2LOS[1] = vec2LOS[1]*flLen;
}

//Do a makevector to make v_forward right
engfunc(EngFunc_MakeVectors,CoreAngles);

new Float:v_forward[3];
new Float:v_forward2D[2];
get_global_vector(GL_v_forward, v_forward);

v_forward2D[0] = v_forward[0];
v_forward2D[1] = v_forward[1];

flDot = vec2LOS[0]*v_forward2D[0]+vec2LOS[1]*v_forward2D[1];

if ( flDot > 0.5 )
{
return flDot;
}

return 0.0;
}
stock Float:Vec2DLength( Float:Vec[2] ) 
{
return floatsqroot(Vec[0]*Vec[0] + Vec[1]*Vec[1] );
}