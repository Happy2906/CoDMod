/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <engine>
#include <fakemeta> 
#include <fun>
#include <cstrike>
#include <amxmisc>
#include <codmod>

#define AUTHOR "J River"

#define MAX 32			 //Max number of valid player entities

#define x 0
#define y 1
#define z 2

new const perk_name[] = "Medicine Glar";
new const perk_desc[] = "Mozesz aktywowac tarcze na graczu. Zadawane dmg w polaczonego zabijaja atakujacego.";

new bool:ma_perk[33]
new player_b_teamheal[33] = 0	//How many hp to heal when shooting a teammate 
new bool:used_item[33] 
new sprite_laser = 0
new gmsgDeathMsg
new gmsgScoreInfo

//Flags a user can have
enum
{
	Flag_Ignite = 0,
	Flag_Hooking,
	Flag_Rot,
	Flag_Dazed,
	Flag_Illusion,
	Flag_Moneyshield,
	Flag_Teamshield,
	Flag_Teamshield_Target,
	num_of_flags
}


//Flags
new afflicted[33][num_of_flags]

public plugin_init() 
{
	register_plugin(perk_name, "1.0", AUTHOR);
	
	cod_register_perk(perk_name, perk_desc, 12, 24);
	
	register_logevent("RoundStart", 2, "0=World triggered", "1=Round_Start")
	
	register_think("Effect_Teamshield","Effect_Teamshield_Think")
	
	register_event("Damage", "Damage", "b", "2!0")
	
	gmsgDeathMsg = get_user_msgid("DeathMsg")
	
	gmsgScoreInfo = get_user_msgid("ScoreInfo") 
	
	set_msg_block ( gmsgDeathMsg, BLOCK_SET )
	
	register_event("DeathMsg","DeathMsg","ade") 
	
}

public cod_perk_enabled(id, wartosc)
{
	client_print(id, print_chat, "Perk stworzony przez J River")
	player_b_teamheal[id] = wartosc;
	ma_perk[id] = false;
}

public cod_perk_disabled(id)
{
	ma_perk[id] = false;
	player_b_teamheal[id] = 0	//How many hp to heal when shooting a teammate 
}
public client_PreThink ( id ) 
{	 
	//USE Button actives USEMAGIC
	if (pev(id,pev_button) & IN_USE )
		if (player_b_teamheal[id] > 0) item_teamshield(id)
	
	return PLUGIN_CONTINUE	
	
}
public DeathMsg()
{
	new weaponname[20]
	new kid = read_data(1)
	new vid = read_data(2) 
	new headshot = read_data(3)
	read_data(4,weaponname,31)

	if (is_user_connected(kid) && is_user_connected(vid) && get_user_team(kid) != get_user_team(vid))
		show_deadmessage(kid,vid,headshot,weaponname)
}
public show_deadmessage(killer_id,victim_id,headshot,weaponname[])
{
	if (!(killer_id==victim_id && !headshot && equal(weaponname,"world")))
	{
		message_begin( MSG_ALL, gmsgDeathMsg,{0,0,0},0)
		write_byte(killer_id)
		write_byte(victim_id)
		write_byte(headshot)
		write_string(weaponname)
		message_end()
	}
}
public RoundStart()
{
	for (new i=0; i < 33; i++)
		used_item[i] = false
}
public plugin_precache()
{
	sprite_laser = precache_model("sprites/laserbeam.spr")
}
public Damage(id)
{
	if (is_user_connected(id))
	{
		new damage = read_data(2)
		new weapon
		new bodypart
		new attacker_id = get_user_attacker(id,weapon,bodypart) 
		if (is_user_connected(attacker_id) && attacker_id != id)
		{
			if (HasFlag(attacker_id,Flag_Ignite))
				RemoveFlag(attacker_id,Flag_Ignite)
				
			if (HasFlag(id,Flag_Teamshield_Target))
			{
				//Find the owner of the shield
				new owner = find_owner_by_euser(id,"Effect_Teamshield")
				if (is_user_alive(owner))
					Hurt_Entity(owner,attacker_id,damage+0.2)
			}
		}
			
			
	}
}

/* ==================================================================================================== */
stock RemoveFlag(id,flag)
{
	afflicted[id][flag] = 0
}
public item_teamshield(id)
{
	if (used_item[id])
	{
		RemoveFlag(id,Flag_Teamshield)
		used_item[id] = false
	}
	else
	{
		new target = Find_Best_Angle(id,1000.0,true)
		
		if (!is_valid_ent(target))
		{
			set_hudmessage(255, 0, 0, -1.0, -1.0, 0, 6.0, 2.2)
			show_hudmessage(id, "Brak celu w zasiegu tarczy")
			return PLUGIN_CONTINUE
		}
		/*
		if (pev(target,pev_rendermode) == kRenderTransTexture)
		{
			set_hudmessage(255, 0, 0, -1.0, -1.0, 0, 6.0, 2.2)
			show_hudmessage(id, "Nie mozesz aktywowac tarczy na niewidzialnych graczach")
			return PLUGIN_CONTINUE
		}
		*/
		if (find_ent_by_owner(-1,"Effect_Teamshield",id) > 0)
			return PLUGIN_CONTINUE
		
		new ent = Spawn_Ent("info_target")
		set_pev(ent,pev_classname,"Effect_Teamshield")
		set_pev(ent,pev_owner,id)
		set_pev(ent,pev_solid,SOLID_NOT)
		set_pev(ent,pev_nextthink, halflife_time() + 0.1)	
		set_pev(ent,pev_euser2, target)	
				
		AddFlag(id,Flag_Teamshield)
		AddFlag(target,Flag_Teamshield_Target)
		used_item[id] = true
	}
	
	return PLUGIN_CONTINUE
}

public Effect_Teamshield_Think(ent)
{
	new id = pev(ent,pev_owner)
	new victim = pev(ent,pev_euser2)
	new target = Find_Best_Angle(id,750.0,true)

				
	if (!is_valid_ent(target) || !is_user_alive(id) || !is_user_alive(victim) || !Can_Trace_Line(id,victim) || !UTIL_In_FOV(id,victim) || !HasFlag(id,Flag_Teamshield))
	{
		set_rendering (victim, kRenderFxNone, 0,0,0, kRenderFxNone, 0 ) 
		RemoveFlag(id,Flag_Teamshield)
		RemoveFlag(victim,Flag_Teamshield_Target)
		remove_entity(ent)
		return PLUGIN_CONTINUE
	}
	else		
		set_pev(ent,pev_nextthink, halflife_time() + 0.3)
				
	new origin1[3]
	new origin2[3]
	
	get_user_origin(id,origin1)
	get_user_origin(victim,origin2)
	
	message_begin(MSG_BROADCAST,SVC_TEMPENTITY) 
	write_byte (TE_BEAMPOINTS)
	write_coord(origin1[0])
	write_coord(origin1[1])
	write_coord(origin1[2]+8)
	write_coord(origin2[0])
	write_coord(origin2[1])
	write_coord(origin2[2]+8)
	write_short(sprite_laser);
	write_byte(1) // framestart 
	write_byte(1) // framerate 
	write_byte(3) // life 
	write_byte(5) // width 
	write_byte(10) // noise 
	write_byte(0) // r, g, b (red)
	write_byte(255) // r, g, b (green)
	write_byte(0) // r, g, b (blue)
	write_byte(45) // brightness 
	write_byte(5) // speed 
	message_end()    
	
	set_rendering ( victim, kRenderFxGlowShell, 0,200,0, kRenderFxNone, 0 ) 
	
	return PLUGIN_CONTINUE
}
stock AddFlag(id,flag)
{
	afflicted[id][flag] = 1	
}
stock Find_Best_Angle(id,Float:dist, same_team = false)
{
	new Float:bestangle = 0.0
	new winner = -1
	
	for (new i=0; i < MAX; i++)
	{
		if (!is_user_alive(i) || i == id || (get_user_team(i) == get_user_team(id) && !same_team))
			continue
		
		if (get_user_team(i) != get_user_team(id) && same_team)
			continue
		
		//User has spell immunity, don't target
		
		new Float:c_angle = Find_Angle(id,i,dist)
		
		if (c_angle > bestangle && Can_Trace_Line(id,i))
		{
			winner = i
			bestangle = c_angle
		}
		
	}
	
	return winner
}
stock bool:Can_Trace_Line(id, target)
{	
	for (new i=-35; i < 60; i+=35)
	{		
		new Float:Origin_Id[3]
		new Float:Origin_Target[3]
		new Float:Origin_Return[3]
		
		pev(id,pev_origin,Origin_Id)
		pev(target,pev_origin,Origin_Target)
		
		Origin_Id[z] = Origin_Id[z] + i
		Origin_Target[z] = Origin_Target[z] + i
		
		trace_line(-1, Origin_Id, Origin_Target, Origin_Return) 
		
		if (get_distance_f(Origin_Return,Origin_Target) < 55.0)
			return true
		
	}
	
	return false
}
stock Spawn_Ent(const classname[]) 
{
	new ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, classname))
	set_pev(ent, pev_origin, {0.0, 0.0, 0.0})    
	dllfunc(DLLFunc_Spawn, ent)
	return ent
}
stock Float:Find_Angle(Core,Target,Float:dist)
{
	new Float:vec2LOS[2]
	new Float:flDot	
	new Float:CoreOrigin[3]
	new Float:TargetOrigin[3]
	new Float:CoreAngles[3]
	
	pev(Core,pev_origin,CoreOrigin)
	pev(Target,pev_origin,TargetOrigin)
	
	if (get_distance_f(CoreOrigin,TargetOrigin) > dist)
		return 0.0
	
	pev(Core,pev_angles, CoreAngles)
	
	for ( new i = 0; i < 2; i++ )
		vec2LOS[i] = TargetOrigin[i] - CoreOrigin[i]
	
	new Float:veclength = Vec2DLength(vec2LOS)
	
	//Normalize V2LOS
	if (veclength <= 0.0)
	{
		vec2LOS[x] = 0.0
		vec2LOS[y] = 0.0
	}
	else
	{
		new Float:flLen = 1.0 / veclength;
		vec2LOS[x] = vec2LOS[x]*flLen
		vec2LOS[y] = vec2LOS[y]*flLen
	}
	
	//Do a makevector to make v_forward right
	engfunc(EngFunc_MakeVectors,CoreAngles)
	
	new Float:v_forward[3]
	new Float:v_forward2D[2]
	get_global_vector(GL_v_forward, v_forward)
	
	v_forward2D[x] = v_forward[x]
	v_forward2D[y] = v_forward[y]
	
	flDot = vec2LOS[x]*v_forward2D[x]+vec2LOS[y]*v_forward2D[y]
	
	if ( flDot > 1.0 )
	{
		return flDot
	}
	
	return 0.0	
}
stock bool:Can_Trace_Line_Origin(Float:origin1[3], Float:origin2[3])
{	
	new Float:Origin_Return[3]	
	new Float:temp1[3]
	new Float:temp2[3]
	
	temp1[x] = origin1[x]
	temp1[y] = origin1[y]
	temp1[z] = origin1[z]-30
	
	temp2[x] = origin2[x]
	temp2[y] = origin2[y]
	temp2[z] = origin2[z]-30
	
	trace_line(-1, temp1, temp2, Origin_Return) 
	
	if (get_distance_f(Origin_Return,temp2) < 2.5)
		return true
	
	return false
}
stock Float:Vec2DLength( Float:Vec[2] )  
{ 
	return floatsqroot(Vec[x]*Vec[x] + Vec[y]*Vec[y] )
}

stock bool:UTIL_In_FOV(id,target)
{
	if (Find_Angle(id,target,9999.9) > 0.0)
		return true
	
	return false
}
stock bool:HasFlag(id,flag)
{
	if (afflicted[id][flag])
		return true
	
	return false
}
/* ==================================================================================================== */	

//Find the owner that has target as target and the specific classname
public find_owner_by_euser(target,classname[])
{
	new ent = -1
	ent = find_ent_by_class(ent,classname)

	while (ent > 0)
	{
		if (pev(ent,pev_euser2) == target)
			return pev(ent,pev_owner)
		ent = find_ent_by_class(ent,classname)
	}
	
	return -1
}
stock Hurt_Entity(attacker,victim,Float:amount)
{
	if (get_user_health(victim)-amount <= 1)
	{
		UTIL_Kill(attacker,victim,"world")
	}
	else
	{
		fakedamage(victim,"player",amount,DMG_ENERGYBEAM)
	}
}
public UTIL_Kill(attacker,id,weapon[])
{
	
	if(get_user_team(attacker)!=get_user_team(id))
		set_user_frags(attacker,get_user_frags(attacker) +1);
	if(get_user_team(attacker)==get_user_team(id))
		set_user_frags(attacker,get_user_frags(attacker) -1);
		
	if (cs_get_user_money(attacker) + 150 <= 16000)
		cs_set_user_money(attacker,cs_get_user_money(attacker)+150)
	else
		cs_set_user_money(attacker,16000)
	
	cod_set_user_xp(id,cod_get_user_xp(id)+50)
	user_kill(id,1) 
	message_begin( MSG_ALL, gmsgDeathMsg,{0,0,0},0) 
	write_byte(attacker) 
	write_byte(id) 
	write_byte(0) 
	write_string(weapon) 
	message_end() 
	
	message_begin(MSG_ALL,gmsgScoreInfo) 
	write_byte(attacker) 
	write_short(get_user_frags(attacker)) 
	write_short(get_user_deaths(attacker)) 
	write_short(0) 
	write_short(get_user_team(attacker)) 
	message_end() 
	
	message_begin(MSG_ALL,gmsgScoreInfo) 
	write_byte(id) 
	write_short(get_user_frags(id)) 
	write_short(get_user_deaths(id)) 
	write_short(0) 
	write_short(get_user_team(id)) 
	message_end() 
	
	new kname[32], vname[32], kauthid[32], vauthid[32], kteam[10], vteam[10];
	
	get_user_name(attacker, kname, 31);
	get_user_team(attacker, kteam, 9);
	get_user_authid(attacker, kauthid, 31);
	
	get_user_name(id, vname, 31);
	get_user_team(id, vteam, 9);
	get_user_authid(id, vauthid, 31);
	
	log_message("^"%s<%d><%s><%s>^" killed ^"%s<%d><%s><%s>^" with ^"%s^"", 
	kname, get_user_userid(attacker), kauthid, kteam, 
	vname, get_user_userid(id), vauthid, vteam, weapon);
	
	
}
